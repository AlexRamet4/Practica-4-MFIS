load time

fmod IDS is

    pr STRING .
    sort Id .
    op id : String -> Id .

endfm

fmod RESOURCES is

    pr IDS .
    pr NAT .

    sort Resource .
    op resource : Id Nat Nat -> Resource [ctor] .

endfm

fmod GATEWAY is 

    sort Gateway .
    op exclusive : -> Gateway [ctor] .
    op parallel : -> Gateway [ctor] .
  
endfm

view Id from TRIV to IDS is
    sort Elt to Id .
endv

mod NODES is 
    sort Node .
    pr IDS .
    pr GATEWAY .
    pr TIME .
    pr SET{Id} .

    op start : Id Id -> Node [ctor] .
    op end : Id Id -> Node [ctor] .
    op task : Id String Id Id Time Set{Id} -> Node [ctor] .
    op split : Id Gateway Id Set{Id} -> Node [ctor] .
    op merge : Id Gateway Set{Id} Id -> Node [ctor] .

endm

mod FLOWS is

    pr IDS .
    pr TIME .
    
    sort Flow .

    op flow : Id Time -> Flow [ctor] .

endm

mod TOKENS is

    pr IDS .
    pr TIME .
    sort Token . 

    op token : Id Time -> Token [ctor] .

endm



view Node from TRIV to NODES is
    sort Elt to Node .
endv

view Flow from TRIV to FLOWS is
    sort Elt to Flow .
endv

view Resource from TRIV to RESOURCES is
    sort Elt to Resource .
endv

view Token from TRIV to TOKENS is
    sort Elt to Token .
endv


mod PROCESS is

    inc CONFIGURATION .
    pr NAT .
    pr NAT-TIME-DOMAIN-WITH-INF .

    pr SET{Node} .
    pr SET{Flow} .
    pr SET{Resource} .
    pr SET{Token} .
    
    sort Process .
    subsort Process < Cid .
    subsort Nat < Oid .

    op Process : -> Process .

    op nodes:_ : Set{Node} -> Attribute [gather (&)] .
    op flows:_ : Set{Flow} -> Attribute [gather (&)] .
    op tokens:_ : Set{Token} -> Attribute [gather (&)] .
    op gtime:_ : Time -> Attribute [gather (&)] .
    op resources:_ : Set{Resource} -> Attribute [gather (&)] .

    vars T T' : Time .
    vars S S' : String .
    var ST : Set{Token} .
    vars RS RS' : Set{Id} . --- Set{Resource}
    vars F F' : Flow .
    var G : Gateway .
    var FS : Set{Id} . --- Set{Flows}
    vars id0 id1 id2 id3 id4 : Id .
    var O : Oid .
    vars N N' : Nat .
    var Atts : AttributeSet .
    var NDS : Set{Node} .
    var FWS : Set{Flow} .
    var RCS : Set{Resource} .
    
    op mte : Set{Token} Set{Node} Set{Flow} Set{Resource} -> Time .
    eq mte(empty, NDS, FWS, RCS) = INF .

    ceq mte((token(id0, T), ST), (merge(id1, parallel, (id0, FS), id2), NDS), (flow(id0, T'), FWS ), RCS) = 
    mte(ST, (merge(id1, parallel, (id0, FS), id2), NDS), (flow(id0, T'), FWS ), RCS) 
    if allZero(tokensCoincidenFlows(FS, (token(id0, T), ST)))  == false .

    ceq mte((token(id0, 0), ST), (task(id1, S, id0, id2, T, RS), NDS), (flow(id0, T'), FWS), RCS) =
    mte(ST, (task(id1, S, id0, id2, T, RS), NDS), (flow(id0, T'), FWS ), RCS) 
    if resourceCoinciden(RCS, RS) == false .

    eq mte((token(id0, 0), ST), (end(id0, id1) , NDS), FWS, RCS) = mte(ST, (end(id0, id1), NDS), FWS, RCS) .

    eq mte((token(id0, T), ST), NDS, FWS, RCS) = min(T, mte(ST, NDS, FWS, RCS)) .


    op delta : Set{Token} Time -> Set{Token} .
    eq delta(empty, T) = empty .
    eq delta((token(id(S), T), ST), T') = union(token(id(S), T monus T'), delta(ST, T')) .

    op flowToToken :  Set{Id} Set{Flow} -> Set{Token} .
    eq flowToToken(empty, FWS) = empty .
    eq flowToToken((id0, FS), (flow(id0, T), FWS)) = union(token(id0,T), flowToToken(FS, FWS)) .

    op deleteTokens : Set{Id} Set{Token} -> Set{Token} .
    eq deleteTokens(empty, ST) = ST .
    eq deleteTokens(FS, empty) = empty .
    eq deleteTokens((id0, FS), (token(id0, T), ST)) = deleteTokens(FS, ST) .
    ceq deleteTokens((id0, FS), (token(id1, T), ST)) = deleteTokens(FS, (token(id1, T), ST)) if id1 =/= id0 .

    op tokensCoincidenFlows : Set{Id} Set{Token} -> Set{Token} .
    eq tokensCoincidenFlows(empty, ST) = empty .
    eq tokensCoincidenFlows(FS, empty) = empty .
    eq tokensCoincidenFlows((id0, FS), (token(id0, T), ST)) = (token(id0, T), tokensCoincidenFlows(FS, ST)) .
    ceq tokensCoincidenFlows((id0, FS), (token(id1, T), ST)) = tokensCoincidenFlows(FS, ST) if id0 =/= id1 .

    op allZero : Set{Token} -> Bool .
    eq allZero(empty) = true .
    ceq allZero((token(id0, T), ST)) = false if  T =/= 0 .
    ceq allZero((token(id0, T), ST)) = allZero(ST) if T == 0 .

    op resourceCoinciden : Set{Resource} Set{Id} -> Bool .
    eq resourceCoinciden(empty, RS) = true .
    eq resourceCoinciden(RCS, empty) = false .
    ceq resourceCoinciden((resource(id0, N, N'), RCS), (id1, RS)) = resourceCoinciden((resource(id0, N, N'), RCS), RS) if id0 =/= id1 .
    ceq resourceCoinciden((resource(id0, N, N'), RCS), (id0, RS)) = resourceCoinciden(RCS, RS) if N' > 0 .
    ceq resourceCoinciden((resource(id0, N, N'), RCS), (id0, RS)) = false if N' == 0 .

    op aumResources : Set{Id} Set{Resource} -> Set{Resource} .
    eq aumResources(empty, RCS) = RCS .
    eq aumResources((id0, RS), (resource(id0, N, N'), RCS)) = aumResources(RS, (resource(id0, N, s(N')), RCS)) .
    ceq aumResources((id0, RS), (resource(id1, N, N'), RCS)) = aumResources(RS, (resource(id0, N, N'), RCS)) if id1 =/= id0 .

    op disResources : Set{Id} Set{Resource} -> Set{Resource} .
    eq disResources(empty, RCS) = RCS .
    eq disResources((id0, RS), (resource(id0, N, s(N')), RCS)) = disResources(RS, (resource(id0, N, N'), RCS)) .
    ceq disResources((id0, RS), (resource(id1, N, N'), RCS)) = disResources(RS, (resource(id0, N, N'), RCS)) if id1 =/= id0 .

    rl [start]  :  < O : Process | 
    nodes: (start(id0, id1), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (token(id0, 0), ST), 
    Atts > 
    => 
    < O : Process | 
    nodes: (start(id0, id1), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (token(id1, T), ST), 
    Atts > .

    rl [flow-node] : < O : Process |
    nodes: (task(id0, S, id1, id2, T, empty), NDS), --- Todo: es posible q haya q hacer una regla con recursos en empty y otra q si tenga cositas
    flows: FWS,
    tokens: (token(id1, 0), ST),
    Atts > 
    =>
    < O : Process |
    nodes: (task(id0, S, id1, id2, T, empty), NDS),
    flows: FWS,
    tokens: (token(id0, T), ST),
     Atts > .

    rl [node-flow] : < O : Process |
    nodes: (task(id0, S, id1, id2, T, empty), NDS), --- Todo: es posible q haya q hacer una regla con recursos en empty y otra q si tenga cositas
    flows: (flow(id2, T'), FWS),
    tokens: (token(id0, 0), ST),
    Atts > 
    =>
    < O : Process |
    nodes: (task(id0, S, id1, id2, T, empty), NDS),
    flows: (flow(id2, T'), FWS),
    tokens: (token(id2, T'), ST),
    Atts > .

    rl [flow-end]  :  < O : Process | 
    nodes: (end(id0, id1), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (token(id1, 0), ST), 
    Atts > 
    => 
    < O : Process | 
    nodes: (end(id0, id1), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (token(id0, 0), ST), 
    Atts > .

    rl [flow-split-and] : < O : Process | 
    nodes: (split(id0, parallel, id1, FS), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (token(id1, 0), ST), 
    Atts > 
    =>
    < O : Process | 
    nodes: (split(id0, parallel, id1, FS), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (flowToToken(FS, (flow(id1, T), FWS)), ST), 
    Atts > .

    rl [flow-split-or] : < O : Process | 
    nodes: (split(id0, exclusive, id1, (id2, FS)), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (token(id1, 0), ST), 
    Atts > 
    =>
    < O : Process | 
    nodes: (split(id0, exclusive, id1, FS), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (flowToToken(id2, (flow(id1, T), FWS)), ST), 
    Atts > .

    crl [flow-merge-and] : < O : Process |  
    nodes: (merge(id0, parallel, (id1, FS), id3), NDS),
    flows: (flow(id3, T), FWS), 
    tokens: (token(id1, 0), ST), 
    Atts > 
    =>
    < O : Process | 
    nodes: (merge(id0, parallel, (id1, FS), id3), NDS),
    flows: (flow(id3, T), FWS),
    tokens: (token(id3, T), deleteTokens(FS, ST)),
    Atts > if allZero(tokensCoincidenFlows(FS, ST)) .

    rl [flow-merge-or] : < O : Process | 
    nodes: (merge(id0, exclusive, (id1, FS), id3), NDS),
    flows: (flow(id3, T), FWS),
    tokens: (token(id1, 0), ST), 
    Atts > 
    =>
    < O : Process | 
    nodes: (merge(id0, exclusive, (id1, FS), id3), NDS),
    flows: (flow(id3, T) , FWS),
    tokens: (token(id3, T), deleteTokens(FS, ST)), 
    Atts > .

    crl [flow-node-resource] : < O : Process |
    nodes: ((task(id0, S, id1, id2, T, RS), NDS)),
    flows: FWS,
    tokens: (token(id1, 0), ST),
    resources: RCS,
    Atts > 
    =>
    < O : Process |
    nodes: ((task(id0, S, id1, id2, T, RS), NDS)),
    flows: FWS,
    tokens: (token(id0, T), ST),
    resources: disResources(RS, RCS), --- restar a todos los recursos
    Atts > if resourceCoinciden(RCS, RS) and RS =/= empty and RCS =/= empty .

    crl [node-flow-resource] : < O : Process |
    nodes: ((task(id0, S, id1, id2, T, RS), NDS)),
    flows: (flow(id2, T'), FWS),
    tokens: (token(id0, 0), ST),
    resources: RCS,
    Atts > 
    =>
    < O : Process |
    nodes: ((task(id0, S, id1, id2, T, RS), NDS)),
    flows: (flow(id2, T'), FWS),
    tokens: (token(id2, T'), ST),
    resources: aumResources(RS, RCS), --- aumentar a todos los recursos
    Atts > if RS =/= empty and RCS =/= empty .

    crl [tick] : < O : Process | nodes: NDS, flows: FWS, tokens: ST, gtime: T, resources: RCS, Atts >
        => < O : Process | nodes: NDS, flows: FWS, tokens: delta(ST, T'), gtime: T + T', resources: RCS, Atts >  --- Delta reduce T'  a todos los tokens
        if T' := mte(ST, NDS, FWS, RCS) /\ T' > 0 .

    op prueba1 : -> Object .
    eq prueba1 = < 0 : Process | 
    nodes: (start(id("N0"), id("F0")), 
           end(id("N1"), id("F0"))),
    flows: flow(id("F0"), 1),
    tokens: token(id("N0"), 0),
    gtime: 0,
    resources: empty > .

    op prueba2 : -> Object .
    eq prueba2 = < 0 : Process | 
    nodes: (start(id("N0"), id("F0")), 
           task(id("T0"), "Patata", id("F0"), id("F1"), 2, empty),
           end(id("N1"), id("F1"))),
    flows: (flow(id("F0"), 1), flow(id("F1"), 3)),
    tokens: token(id("N0"), 0),
    gtime: 0,
    resources: empty > .

    op prueba3 : -> Object .
    eq prueba3 = < 0 : Process | 
    nodes: (start(id("N0"), id("F0")), 
           task(id("T0"), "Patata", id("F0"), id("F1"), 2, empty),
           split(id("S0"), parallel, id("F1"), (id("F2"), id("F3"))),
           end(id("N1"), id("F2")),
           end(id("N2"), id("F3"))),
    flows: (flow(id("F0"), 1), flow(id("F1"), 3), flow(id("F2"), 1), flow(id("F3"), 2)),
    tokens: token(id("N0"), 0),
    gtime: 0,
    resources: empty > .

    op prueba4 : -> Object .
    eq prueba4 = < 0 : Process | 
    nodes: (start(id("N0"), id("F0")), 
           task(id("T0"), "Patata", id("F0"), id("F1"), 2, empty),
           split(id("S0"), exclusive, id("F1"), (id("F2"), id("F3"))),
           end(id("N1"), id("F2")),
           end(id("N2"), id("F3"))),
    flows: (flow(id("F0"), 1), flow(id("F1"), 3), flow(id("F2"), 1), flow(id("F3"), 2)),
    tokens: token(id("N0"), 0),
    gtime: 0,
    resources: empty > .
    
    op prueba5 : -> Object .
    eq prueba5 = < 0 : Process | 
    nodes: (start(id("N0"), id("F0")), 
           task(id("T0"), "Patata", id("F0"), id("F1"), 2, empty),
           split(id("S0"), parallel, id("F1"), (id("F2"), id("F3"))),
           merge(id("S0"), exclusive, (id("F2"), id("F3")), id("F4")),
           end(id("N1"), id("F4"))),
    flows: (flow(id("F0"), 1), flow(id("F1"), 3), flow(id("F2"), 1), flow(id("F3"), 2), flow(id("F4"), 4)),
    tokens: token(id("N0"), 0),
    gtime: 0,
    resources: empty > .

    op prueba6 : -> Object .
    eq prueba6 = < 0 : Process | 
    nodes: (start(id("N0"), id("F0")), 
           task(id("T0"), "Patata", id("F0"), id("F1"), 2, empty),
           split(id("S0"), parallel, id("F1"), (id("F2"), id("F3"))),
           merge(id("S0"), parallel, (id("F2"), id("F3")), id("F4")),
           end(id("N1"), id("F4"))),
    flows: (flow(id("F0"), 1), flow(id("F1"), 3), flow(id("F2"), 1), flow(id("F3"), 2), flow(id("F4"), 4)),
    tokens: token(id("N0"), 0),
    gtime: 0,
    resources: empty > .

    op prueba7 : -> Object .
    eq prueba7 = < 0 : Process | 
    nodes: (start(id("N0"), id("F0")), 
           task(id("T1"), "Patata", id("F2"), id("F3"), 5, (id("R0"))),
           task(id("T0"), "Ortu me cae mal", id("F1"), id("F4"), 2, (id("R0"))),
           split(id("S0"), parallel, id("F0"), (id("F1"), id("F2"))),
           end(id("N2"), id("F3")),
           end(id("N3"), id("F4"))),
    flows: (flow(id("F0"), 1), flow(id("F1"), 2), flow(id("F2"), 3), flow(id("F3"), 1), flow(id("F4"), 2)),
    tokens: token(id("N0"), 0),
    gtime: 0,
    resources: resource(id("R0"), 1, 1) > .

endm 
