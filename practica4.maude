---mod REGLAS is
---    protecting TOKENS .
---    rl [ejemplo] : < O : Process | 
---        nodes: (task(Nid, St, Fid1, Fid2, T, Rcs, SE0, SE1), Nodes), --- Se queda fijo. Sirven de información (parametros de entrada)
---        flows: (flow(Fid1, T1), flow(Fid2, T2), Flows), 
---        tokens: (token(Fid1, 0), Tokens),  --- Si lo tenemos en una lista ordenada sabemos cual es el siguiente token que tenemos que usar 
---        Atts > 
---            => 
---        if available(RIds, Rs) then
---            < O : Process | 
---            nodes: (task(Nid, St, Fid1, Fid2, T, Rcs, SE0, SE1), Nodes), --- Se queda fijo
---            flows: (flow(Fid1, T1), flow(Fid2, T2), Flows), 
---            tokens: (add(token, id("20"), T), Tokens),  --- Añadimos el nuevo token a la lista del token cuando se consume
---            Atts > 
---        else 
---            --- buscamos la primera regla que cumpla las condiciones para activarse, y ponerlo en la cabeza
---        fi .

---regla de tick
---crl [tick] :
---{Conf, T}
---=>
---{ delta(Conf, T'), t+ T'}
---if T' := mte(conf)
---
---la funcion delta reduce los temporizadores de todos los tokens. Al menos lo de arriba era hasta ahora. en la practica sería del tipo:
---
---crl < O : Process | gtime: T, tokens: TKS, Atts >
---=>
---< O : Process | gtime: T + T', tokens: delta(TKS, T'), Atts > . --- Delta reduce T'  a todos los tokens
---if T' := mte(TKS) /\ T' 0 .
---    
---endm

---fmod PROCESS is
---    including CONFIGURATION .
---    
---
---    < O : Process | 
---    nodes: start(id("O1"), id("O2")),
---           task(id("O3"), "Sign in", id("O2"), id("O4"), T, empty, empty, empty), --- (,,, tiempo de la tarea, conjunto de id de recursos necesarios para correr la tare o empty, conjunto de , conjunto de)
---           merge(id("O5"), exclusive, (id("O4,"), id("O10")), id("O6")),
---    flows: flow(id("O2"), 2), --- El 2 es el retraso del flujo
---           flow(id("O4"), 3)
---    tokens: 
---    gTime: T,
---    resources: (resource(id("car"), 5, 5))
---
---endfm
load time

fmod IDS is

    pr STRING .
    sort Id .
    op id : String -> Id .

endfm

fmod RESOURCES is

    pr IDS .
    pr NAT .

    sort Resource .
    op resource : Id Nat Nat -> Resource [ctor] .

endfm

fmod GATEWAY is 

    sort Gateway .
    op exclusive : -> Gateway [ctor] .
    op parallel : -> Gateway [ctor] .
    op event-based : -> Gateway [ctor] .
  
endfm

view Id from TRIV to IDS is
    sort Elt to Id .
endv

mod NODES is 
    sort Node .
    pr IDS .
    pr GATEWAY .
    pr TIME .
    pr SET{Id} .

    op start : Id Id -> Node [ctor] .
    op end : Id Id -> Node [ctor] .
    op task : Id String Id Id Time Set{Id} Set{Id} Set{Id} -> Node [ctor] .
    op split : Id Gateway Id Set{Id} -> Node [ctor] .
    op merge : Id Gateway Set{Id} Id -> Node [ctor] .

endm

fmod MESSAGES is

    pr STRING .
    sort Event .
    pr IDS .
    op msg : Id -> Event [ctor] .

endfm


mod FLOWS is

    pr IDS .
    pr MESSAGES .
    pr TIME .
    
    sort Flow .

    op flow : Id Event Id -> Flow [ctor] .
    op flow : Id Time -> Flow [ctor] .

endm

mod TOKENS is

    pr IDS .
    pr TIME .
    sort Token . 

    op token : Id Time -> Token [ctor] .

endm



view Node from TRIV to NODES is
    sort Elt to Node .
endv

view Flow from TRIV to FLOWS is
    sort Elt to Flow .
endv

view Resource from TRIV to RESOURCES is
    sort Elt to Resource .
endv

view Token from TRIV to TOKENS is
    sort Elt to Token .
endv

view Event from TRIV to MESSAGES is
    sort Elt to Event .
endv


mod PROCESS is

    inc CONFIGURATION .
    pr NAT .
    pr NAT-TIME-DOMAIN .

    pr SET{Node} .
    pr SET{Flow} .
    pr SET{Resource} .
    pr SET{Event} .
    pr LIST{Token} .
    
    sort Process .
    subsort Process < Cid .
    subsort Nat < Oid .

    op Process : -> Process .

    op nodes:_ : Set{Node} -> Attribute [gather (&)] .
    op flows:_ : Set{Flow} -> Attribute [gather (&)] .
    op tokens:_ : List{Token} -> Attribute [gather (&)] .
    op gtime:_ : Time -> Attribute [gather (&)] .
    op resources:_ : Set{Resource} -> Attribute [gather (&)] .
    op events:_ : Set{Event} -> Attribute [gather (&)] .

    vars T T' : Time .
    vars S S' : String .
    var LT : List{Token} .
    vars RS RS' : Set{Id} . --- Set{Resource}
    vars MES MES' MSS : Set{Id} . --- Set{Event}
    vars F F' : Flow .
    var G : Gateway .
    var FS : Set{Id} . --- Set{Flows}
    vars id0 id1 id2 id3 id4 : Id .
    var O : Oid .
    var N : Nat .
    var Atts : AttributeSet .
    var NDS : Set{Node} .
    var FWS : Set{Flow} .
    
    op addToken : Token List{Token} -> List{Token} .

    eq addToken(token(id(S), T), nil) = token(id(S), T) .
    ceq addToken(token(id(S), T), token(id(S'), T') LT) = 
        append(token(id(S), T), token(id(S'), T') LT) 
        if T gt T' == false /\ S =/= S' .

    ceq addToken(token(id(S), T), token(id(S'), T') LT) = 
        append(token(id(S'), T'), addToken(token(id(S), T), LT)) 
        if T gt T' /\ S =/= S' .

    op mte : List{Token} -> Time .
    eq mte(token(id0, T) LT) = T . --- eq mte(LT) = head(PonerPrimeroTareaNoBloqueante(LT)) .

    op delta : List{Token} Time -> List{Token} .
    eq delta(nil, T) = nil .
    eq delta(token(id(S), T) LT, T') = append(token(id(S), T monus T'), delta(LT, T')) .

    --- Nodo, ids de recursos e ids de eventos
    op bloqueante : Node Set{Id} Set{Id} -> Bool .
    eq bloqueante(task(id0, S, id1, id2, T, RS, MES, MSS), RS', MES') = (RS subset RS') and (MES subset MES') == false .
    eq bloqueante(start(id0, id1), RS, MES) = false .
    eq bloqueante(end(id0, id1), RS, MES) = false .
    eq bloqueante(split(id0, G, id1, FS), RS, MES) = false .
    eq bloqueante(merge(id0, G, FS, id1), RS, MES) = false .


    rl [start]  :  < O : Process | 
    nodes: (start(id0, id1), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (token(id0, 0) LT), 
    Atts > 
    => 
    < O : Process | 
    nodes: (start(id0, id1), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (token(id1, T) LT), 
    Atts > .

    rl [flow-node] : < O : Process |
    nodes: (task(id0, S, id1, id2, T, RS, MES, MSS), NDS), --- Todo: es posible q haya q hacer una regla con recursos en empty y otra q si tenga cositas
    flows: FWS,
    tokens: (token(id1, 0) LT),
    Atts > 
    =>
    < O : Process |
    nodes: (task(id0, S, id1, id2, T, RS, MES, MSS), NDS),
    flows: FWS,
    tokens: (token(id0, T) LT),
    Atts > .

    rl [node-flow] : < O : Process |
    nodes: (task(id0, S, id1, id2, T, RS, MES, MSS), NDS), --- Todo: es posible q haya q hacer una regla con recursos en empty y otra q si tenga cositas
    flows: (flow(id2, T'), FWS),
    tokens: (token(id0, 0) LT),
    Atts > 
    =>
    < O : Process |
    nodes: (task(id0, S, id1, id2, T, RS, MES, MSS), NDS),
    flows: (flow(id2, T'), FWS),
    tokens: (token(id2, T') LT),
    Atts > .

    rl [flow-end]  :  < O : Process | 
    nodes: (end(id0, id1), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (token(id1, 0) LT), 
    Atts > 
    => 
    < O : Process | 
    nodes: (end(id0, id1), NDS),
    flows: (flow(id1, 0), FWS),
    tokens: (token(id0, 0) LT), 
    Atts > .


    crl [tick] : < O : Process | gtime: T, tokens: LT, Atts >
        => < O : Process | gtime: T + T', tokens: delta(LT, T'), Atts >  --- Delta reduce T'  a todos los tokens
        if T' := mte(LT) /\ T' > 0 .

    op prueba1 : Nat -> Object .
    eq prueba1(N) = < N : Process | 
    nodes: (start(id("N0"), id("F0")), 
           end(id("N1"), id("F0"))),
    flows: flow(id("F0"), 1),
    tokens: token(id("N0"), 0),
    gtime: 0,
    resources: empty,
    events: empty > .

    op prueba2 : Nat -> Object .
    eq prueba2(N) = < N : Process | 
    nodes: (start(id("N0"), id("F0")), 
           task(id("T0"), "Patata", id("F0"), id("F1"), 2, empty, empty, empty),
           end(id("N1"), id("F1"))),
    flows: (flow(id("F0"), 1), flow(id("F1"), 3)),
    tokens: token(id("N0"), 0),
    gtime: 0,
    resources: empty,
    events: empty > .
    
endm 
