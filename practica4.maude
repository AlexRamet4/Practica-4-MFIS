---mod REGLAS is
---    protecting TOKENS .
---    rl [ejemplo] : < O : Process | 
---        nodes: (task(Nid, St, Fid1, Fid2, T, Rcs, SE0, SE1), Nodes), --- Se queda fijo. Sirven de información (parametros de entrada)
---        flows: (flow(Fid1, T1), flow(Fid2, T2), Flows), 
---        tokens: (token(Fid1, 0), Tokens),  --- Si lo tenemos en una lista ordenada sabemos cual es el siguiente token que tenemos que usar 
---        Atts > 
---            => 
---        if available(RIds, Rs) then
---            < O : Process | 
---            nodes: (task(Nid, St, Fid1, Fid2, T, Rcs, SE0, SE1), Nodes), --- Se queda fijo
---            flows: (flow(Fid1, T1), flow(Fid2, T2), Flows), 
---            tokens: (add(token, id("20"), T), Tokens),  --- Añadimos el nuevo token a la lista del token cuando se consume
---            Atts > 
---        else 
---            --- buscamos la primera regla que cumpla las condiciones para activarse, y ponerlo en la cabeza
---        fi .

---regla de tick
---crl [tick] :
---{Conf, T}
---=>
---{ delta(Conf, T'), t+ T'}
---if T' := mte(conf)
---
---la funcion delta reduce los temporizadores de todos los tokens. Al menos lo de arriba era hasta ahora. en la practica sería del tipo:
---
---crl < O : Process | gtime: T, tokens: TKS, Atts >
---=>
---< O : Process | gtime: T + T', tokens: delta(TKS, T'), Atts > . --- Delta reduce T'  a todos los tokens
---if T' := mte(TKS) /\ T' 0 .
---    
---endm

---fmod PROCESS is
---    including CONFIGURATION .
---    
---
---    < O : Process | 
---    nodes: start(id("O1"), id("O2")),
---           task(id("O3"), "Sign in", id("O2"), id("O4"), T, empty, empty, empty), --- (,,, tiempo de la tarea, conjunto de id de recursos necesarios para correr la tare o empty, conjunto de , conjunto de)
---           merge(id("O5"), exclusive, (id("O4,"), id("O10")), id("O6")),
---    flows: flow(id("O2"), 2), --- El 2 es el retraso del flujo
---           flow(id("O4"), 3)
---    tokens: 
---    gTime: T,
---    resources: (resource(id("car"), 5, 5))
---
---endfm
load time

fmod IDS is

    pr STRING .
    sort Id .
    op id : String -> Id .

endfm

fmod RESOURCES is

    pr IDS .
    pr NAT .

    sort Resource .
    op resource : Id Nat Nat -> Resource [ctor] .

endfm

fmod GATEWAY is 

    sort Gateway .
    op exclusive : -> Gateway [ctor] .
    op parallel : -> Gateway [ctor] .
  
endfm

view Id from TRIV to IDS is
    sort Elt to Id .
endv

mod NODES is 
    sort Node .
    pr IDS .
    pr GATEWAY .
    pr TIME .
    pr SET{Id} .

    op start : Id Id -> Node [ctor] .
    op end : Id Id -> Node [ctor] .
    op task : Id String Id Id Time Set{Id} -> Node [ctor] .
    op split : Id Gateway Id Set{Id} -> Node [ctor] .
    op merge : Id Gateway Set{Id} Id -> Node [ctor] .

endm

mod FLOWS is

    pr IDS .
    pr TIME .
    
    sort Flow .

    op flow : Id Time -> Flow [ctor] .

endm

mod TOKENS is

    pr IDS .
    pr TIME .
    sort Token . 

    op token : Id Time -> Token [ctor] .

endm



view Node from TRIV to NODES is
    sort Elt to Node .
endv

view Flow from TRIV to FLOWS is
    sort Elt to Flow .
endv

view Resource from TRIV to RESOURCES is
    sort Elt to Resource .
endv

view Token from TRIV to TOKENS is
    sort Elt to Token .
endv


mod PROCESS is

    inc CONFIGURATION .
    pr NAT .
    pr NAT-TIME-DOMAIN .

    pr SET{Node} .
    pr SET{Flow} .
    pr SET{Resource} .
    pr SET{Token} .
    
    sort Process .
    subsort Process < Cid .
    subsort Nat < Oid .

    op Process : -> Process .

    op nodes:_ : Set{Node} -> Attribute [gather (&)] .
    op flows:_ : Set{Flow} -> Attribute [gather (&)] .
    op tokens:_ : Set{Token} -> Attribute [gather (&)] .
    op gtime:_ : Time -> Attribute [gather (&)] .
    op resources:_ : Set{Resource} -> Attribute [gather (&)] .

    vars T T' : Time .
    vars S S' : String .
    var ST : Set{Token} .
    vars RS RS' : Set{Id} . --- Set{Resource}
    vars F F' : Flow .
    var G : Gateway .
    var FS : Set{Id} . --- Set{Flows}
    vars id0 id1 id2 id3 id4 : Id .
    var O : Oid .
    var N : Nat .
    var Atts : AttributeSet .
    var NDS : Set{Node} .
    var FWS : Set{Flow} .
    
    op mte : Set{Token} -> Time .
    ceq mte((token(id0, T), ST)) = T if T =/= 0 .
    ceq mte((token(id0, T), ST)) = mte(ST) if T == 0 .

    op delta : Set{Token} Time -> Set{Token} .
    eq delta(empty, T) = empty .
    eq delta((token(id(S), T), ST), T') = union(token(id(S), T monus T'), delta(ST, T')) .

    --- Nodo, ids de recursos e ids de eventos
    op bloqueante : Node Set{Id} -> Bool .
    eq bloqueante(task(id0, S, id1, id2, T, RS), RS') = (RS subset RS') == false .
    eq bloqueante(start(id0, id1), RS) = false .
    eq bloqueante(end(id0, id1), RS) = false .
    eq bloqueante(split(id0, G, id1, FS), RS) = false .
    eq bloqueante(merge(id0, G, FS, id1), RS) = false .

    op flowToToken :  Set{Id} Set{Flow} -> Set{Token} .
    eq flowToToken(empty, FWS) = empty .
    eq flowToToken((id0, FS), (flow(id0, T), FWS)) = union(token(id0,T), flowToToken(FS, FWS)) .

    op deleteTokens : Set{Id} Set{Token} -> Set{Token} .
    eq deleteTokens(empty, ST) = ST .
    eq deleteTokens(FS, empty) = empty .
    eq deleteTokens((id0, FS), (token(id0, T), ST)) = deleteTokens(FS, ST) .
    ceq deleteTokens((id0, FS), (token(id1, T), ST)) = deleteTokens(FS, (token(id1, T), ST)) if id1 =/= id0 .

    op tokensCoincidenFlows : Set{Id} Set{Token} -> Set{Token} .
    eq tokensCoincidenFlows(empty, ST) = empty .
    eq tokensCoincidenFlows(FS, empty) = empty .
    eq tokensCoincidenFlows((id0, FS), (token(id0, T), ST)) = (token(id0, T), tokensCoincidenFlows(FS, ST)) .
    ceq tokensCoincidenFlows((id0, FS), (token(id1, T), ST)) = tokensCoincidenFlows(FS, ST) if id0 =/= id1 .

    op allZero : Set{Token} -> Bool .
    eq allZero(empty) = true .
    ceq allZero((token(id0, T), ST)) = false if  T =/= 0 .
    ceq allZero((token(id0, T), ST)) = allZero(ST) if T == 0 .

    rl [start]  :  < O : Process | 
    nodes: (start(id0, id1), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (token(id0, 0), ST), 
    Atts > 
    => 
    < O : Process | 
    nodes: (start(id0, id1), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (token(id1, T), ST), 
    Atts > .

    rl [flow-node] : < O : Process |
    nodes: (task(id0, S, id1, id2, T, RS), NDS), --- Todo: es posible q haya q hacer una regla con recursos en empty y otra q si tenga cositas
    flows: FWS,
    tokens: (token(id1, 0), ST),
    Atts > 
    =>
    < O : Process |
    nodes: (task(id0, S, id1, id2, T, RS), NDS),
    flows: FWS,
    tokens: (token(id0, T), ST),
    Atts > .

    rl [node-flow] : < O : Process |
    nodes: (task(id0, S, id1, id2, T, RS), NDS), --- Todo: es posible q haya q hacer una regla con recursos en empty y otra q si tenga cositas
    flows: (flow(id2, T'), FWS),
    tokens: (token(id0, 0), ST),
    Atts > 
    =>
    < O : Process |
    nodes: (task(id0, S, id1, id2, T, RS), NDS),
    flows: (flow(id2, T'), FWS),
    tokens: (token(id2, T'), ST),
    Atts > .

    rl [flow-end]  :  < O : Process | 
    nodes: (end(id0, id1), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (token(id1, 0), ST), 
    Atts > 
    => 
    < O : Process | 
    nodes: (end(id0, id1), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (token(id0, 0), ST), 
    Atts > .

    rl [flow-split-and] : < O : Process | 
    nodes: (split(id0, parallel, id1, FS), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (token(id1, 0), ST), 
    Atts > 
    =>
    < O : Process | 
    nodes: (split(id0, parallel, id1, FS), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (flowToToken(FS, (flow(id1, T), FWS)), ST), 
    Atts > .

    rl [flow-split-or] : < O : Process | 
    nodes: (split(id0, exclusive, id1, (id2, FS)), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (token(id1, 0), ST), 
    Atts > 
    =>
    < O : Process | 
    nodes: (split(id0, exclusive, id1, FS), NDS),
    flows: (flow(id1, T), FWS),
    tokens: (flowToToken(id2, (flow(id1, T), FWS)), ST), 
    Atts > .

    crl [flow-merge-and] : < O : Process |  
    nodes: (merge(id0, parallel, (id1, FS), id3), NDS),
    flows: (flow(id3, T), FWS), 
    tokens: (token(id1, 0), ST), 
    Atts > 
    =>
    < O : Process | 
    nodes: (merge(id0, parallel, (id1, FS), id3), NDS),
    flows: (flow(id3, T), FWS),
    tokens: (token(id3, T), deleteTokens(FS, ST)),
    Atts > if allZero(tokensCoincidenFlows(FS, ST)) .

    rl [flow-merge-or] : < O : Process | 
    nodes: (merge(id0, exclusive, (id1, FS), id3), NDS),
    flows: (flow(id3, T), FWS),
    tokens: (token(id1, 0), ST), 
    Atts > 
    =>
    < O : Process | 
    nodes: (merge(id0, exclusive, (id1, FS), id3), NDS),
    flows: (flow(id3, T) , FWS),
    tokens: (token(id3, T), deleteTokens(FS, ST)), 
    Atts > .


    crl [tick] : < O : Process | gtime: T, tokens: ST, Atts >
        => < O : Process | gtime: T + T', tokens: delta(ST, T'), Atts >  --- Delta reduce T'  a todos los tokens
        if T' := mte(ST) /\ T' > 0 .

    op prueba1 : -> Object .
    eq prueba1 = < 0 : Process | 
    nodes: (start(id("N0"), id("F0")), 
           end(id("N1"), id("F0"))),
    flows: flow(id("F0"), 1),
    tokens: token(id("N0"), 0),
    gtime: 0,
    resources: empty > .

    op prueba2 : -> Object .
    eq prueba2 = < 0 : Process | 
    nodes: (start(id("N0"), id("F0")), 
           task(id("T0"), "Patata", id("F0"), id("F1"), 2, empty),
           end(id("N1"), id("F1"))),
    flows: (flow(id("F0"), 1), flow(id("F1"), 3)),
    tokens: token(id("N0"), 0),
    gtime: 0,
    resources: empty > .

    op prueba3 : -> Object .
    eq prueba3 = < 0 : Process | 
    nodes: (start(id("N0"), id("F0")), 
           task(id("T0"), "Patata", id("F0"), id("F1"), 2, empty),
           split(id("S0"), parallel, id("F1"), (id("F2"), id("F3"))),
           end(id("N1"), id("F2")),
           end(id("N2"), id("F3"))),
    flows: (flow(id("F0"), 1), flow(id("F1"), 3), flow(id("F2"), 1), flow(id("F3"), 2)),
    tokens: token(id("N0"), 0),
    gtime: 0,
    resources: empty > .

    op prueba4 : -> Object .
    eq prueba4 = < 0 : Process | 
    nodes: (start(id("N0"), id("F0")), 
           task(id("T0"), "Patata", id("F0"), id("F1"), 2, empty),
           split(id("S0"), exclusive, id("F1"), (id("F2"), id("F3"))),
           end(id("N1"), id("F2")),
           end(id("N2"), id("F3"))),
    flows: (flow(id("F0"), 1), flow(id("F1"), 3), flow(id("F2"), 1), flow(id("F3"), 2)),
    tokens: token(id("N0"), 0),
    gtime: 0,
    resources: empty > .
    
    op prueba5 : -> Object .
    eq prueba5 = < 0 : Process | 
    nodes: (start(id("N0"), id("F0")), 
           task(id("T0"), "Patata", id("F0"), id("F1"), 2, empty),
           split(id("S0"), parallel, id("F1"), (id("F2"), id("F3"))),
           merge(id("S0"), exclusive, (id("F2"), id("F3")), id("F4")),
           end(id("N1"), id("F4"))),
    flows: (flow(id("F0"), 1), flow(id("F1"), 3), flow(id("F2"), 1), flow(id("F3"), 2), flow(id("F4"), 4)),
    tokens: token(id("N0"), 0),
    gtime: 0,
    resources: empty > .

    op prueba6 : -> Object .
    eq prueba6 = < 0 : Process | 
    nodes: (start(id("N0"), id("F0")), 
           task(id("T0"), "Patata", id("F0"), id("F1"), 2, empty),
           split(id("S0"), parallel, id("F1"), (id("F2"), id("F3"))),
           merge(id("S0"), parallel, (id("F2"), id("F3")), id("F4")),
           end(id("N1"), id("F4"))),
    flows: (flow(id("F0"), 1), flow(id("F1"), 3), flow(id("F2"), 1), flow(id("F3"), 2), flow(id("F4"), 4)),
    tokens: token(id("N0"), 0),
    gtime: 0,
    resources: empty > .


endm 
